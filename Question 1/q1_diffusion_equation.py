# -*- coding: utf-8 -*-
"""20B60130_TranHuuNhatHuy_Q1_DiffusionEquation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JPB3Zv_CWdcVKP2m2F66NEKAUwLqXFGJ
"""

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits import mplot3d

# Initial state properties
dx = dy = d = 0.1
alpha = 100
Lx = Ly = L = 10
x = np.arange(0, Lx + dx, dx)
y = np.arange(0, Ly + dy, dy)
g = 9.8

# Simulation runtime properties
N_iter = 10000
N_reset = 100
X, Y = np.meshgrid(x, y)
T = np.zeros((len(x), len(y)))
fig = plt.figure()

# Function to initiate plot with temperature input T
def init_plt3D(T, zmin = -1, zmax = 0.1):
  plt.clf()
  ax = fig.add_subplot(projection = '3d')
  plot = ax.plot_surface(X, Y, T, cmap = 'nipy_spectral')
  ax.set_xlabel('X')
  ax.set_ylabel('Y')
  ax.set_zlim(zmin, zmax)
  plt.colorbar(plot)

# Function to simulate steady-state condition (part 1)
def sim_Steady(T):
  T = np.zeros((len(x), len(y)))
  init_plt3D(T)                                 # Initial state handling
  plt.title("Initial state")
  plt.savefig("Initial state.jpg")              # Capturing initial state
  w = 1.5                                       # Relaxation coefficient (0 < w < 2)
  T[0, :] = T[:, 0] = T[-1, :] = T[:, -1] = 0   # Dirichlet boundary condition, fixed at 0
  # Commencing simulation
  while (True):
    T_min = T[len(x)//2, len(y)//2]             # Section's center, also lowest point
    for i in range(1, len(x) - 1):
      for j in range(1, len(y) - 1):
        # Calculate residue Rk for every iteration
        Rk = 1/4 * (T[i+1, j] + T[i-1, j] + T[i, j+1] + T[i, j-1] - g/alpha*(dx**2))
        # Replace the value of T[i, j] for next iteration by adding Rk
        T[i, j] = (1 - w) * T[i, j] + w * Rk;
    # When the difference of T_min between 2 consecutive iterations is negligible, we terminate the simulation
    if (abs(T_min - T[len(x)//2, len(y)//2]) <= 0.0001):
      init_plt3D(T)
      plt.title("Steady state")
      plt.savefig("steady state.jpg")           # Capturing steady state
      break

def get_T_Dirichlet(T, d):
  T[1:-1, 1:-1] = T[1:-1, 1:-1] + d * (T[1:-1, 2:] + T[1:-1, 0:-2] + T[2:, 1:-1] + T[0:-2, 1:-1] - 4*T[1:-1, 1:-1])
  return T

def get_T_Neumann(T, d):
  g = 0
  T[1: -1, 1: -1] += d*(T[1: -1, 2:] + T[1: -1, 0: -2] + T[2:, 1: -1] + T[0: -2, 1: -1] - 4*T[1: -1, 1: -1])
  T[:, -1] += d*(T[:, -2] - 4*T[:, -1] + T[:, -2] - 2*dx*g + np.roll(T[:, -1], -1, axis = 0) + np.roll(T[:, -1], 1, axis = 0))
  T[:, 0] += d*(T[:, 1] - 4*T[:, 0] + T[:, 1] - 2*dx*g + np.roll(T[:, 0], -1, axis = 0) + np.roll(T[:, 0], 1, axis = 0))
  T[0, :] += d*(T[1, :] - 4*T[0, :] + T[1, :] - 2*dx*g + np.roll(T[0, :], -1, axis = 0) + np.roll(T[0, :], 1, axis = 0))
  T[-1, :] += d*(T[-2, :] - 4*T[-1, :] + T[-2, :] - 2*dx*g + np.roll(T[-1, :], -1, axis = 0) + np.roll(T[-1, :], 1, axis = 0))
  # Recalculating corners 
  T[:, -1] += d*(T[:, -2] - 4*T[:, -1] + T[:, -2] - 2*dx*g + np.roll(T[:, -1], -1, axis = 0) + np.roll(T[:, -1], 1, axis = 0))
  T[:, 0] += d*(T[:, 1] - 4*T[:, 0] + T[:, 1] - 2*dx*g + np.roll(T[:, 0], -1, axis = 0) + np.roll(T[:, 0], 1, axis = 0))
  T[0, :] += d*(T[1, :] - 4*T[0, :] + T[1, :] - 2*dx*g + np.roll(T[0, :], -1, axis = 0) + np.roll(T[0, :], 1, axis = 0))
  T[-1, :] += d*(T[-2, :] - 4*T[-1, :] + T[-2, :] - 2*dx*g + np.roll(T[-1, :], -1, axis = 0) + np.roll(T[-1, :], 1, axis = 0))
  return T

def get_T_Mixed(T, d):
  g = 0
  T[1: -1, 1: -1] = T[1: -1, 1: -1] + d * (T[1: -1, 2:] + T[1: -1, 0: -2] + T[2:, 1: -1] + T[0: -2, 1: -1] - 4*T[1: -1, 1: -1])
  # Let loose the y borders
  T[0, :] += d*(T[1, :] - 4*T[0, :] + T[1, :] - 2*dx*g + np.roll(T[0, :], -1, axis = 0) + np.roll(T[0, :], 1, axis = 0))
  T[-1, :] += d*(T[-2, :] - 4*T[-1, :] + T[-2, :] - 2*dx*g + np.roll(T[-1, :], -1, axis = 0) + np.roll(T[-1, :], 1, axis = 0))
  T[0, :] += d*(T[1, :] - 4*T[0, :] + T[1, :] - 2*dx*g + np.roll(T[0, :], -1, axis = 0) + np.roll(T[0, :], 1, axis = 0))
  T[-1, :] += d*(T[-2, :] - 4*T[-1, :] + T[-2, :] - 2*dx*g + np.roll(T[-1, :], -1, axis = 0) + np.roll(T[-1, :], 1, axis = 0))
  return T

def sim_Other_Boundary(T, d):
  T = np.zeros((len(x), len(y)))
  T[20:80, 30:70] = 1
  for i in range(N_iter):
    # Calculate 3 cases
    T_Dirichlet = get_T_Dirichlet(T, d)
    T_Neumann = get_T_Neumann(T, d)
    T_Mixed = get_T_Mixed(T, d)
    # Plot graphs every N_reset iterations
    if (i % N_reset == 0):
      icount = i // N_reset
      init_plt3D(T_Dirichlet, 0, 1)     ; plt.savefig(f"D{icount:02d}.jpg")
      init_plt3D(T_Neumann, 0, 1)       ; plt.savefig(f"N{icount:02d}.jpg")
      init_plt3D(T_Mixed, 0, 1)         ; plt.savefig(f"M{icount:02d}.jpg")
  # Render animations
  !ffmpeg -r 6 -pattern_type glob -i 'D*.jpg' -vf "scale=trunc(iw/2)*2:trunc(ih/2)*2" -vcodec libx264 -pix_fmt yuv420p Dirichlet.mp4
  !ffmpeg -r 6 -pattern_type glob -i 'N*.jpg' -vf "scale=trunc(iw/2)*2:trunc(ih/2)*2" -vcodec libx264 -pix_fmt yuv420p Neumann.mp4
  !ffmpeg -r 6 -pattern_type glob -i 'M*.jpg' -vf "scale=trunc(iw/2)*2:trunc(ih/2)*2" -vcodec libx264 -pix_fmt yuv420p Mixed.mp4

def sim_dTest(T):
  #d_list = np.arange(0, 1.05, 0.05)
  d_list = np.arange(0.23, 0.29, 0.01)
  for i in range(len(d_list)):
    T[20:80, 30:70] = 1
    # Capture each state with corresponding d, after 100 Dirichlet iterations each
    for j in range(100):
      T = get_T_Dirichlet(T, d_list[i])
    init_plt3D(T, 0, 1)
    plt.title(f"d = {d_list[i]}")
    plt.savefig(f"{i:02d}.jpg")
  # Render animation
  !ffmpeg -r 2 -pattern_type glob -i '*.jpg' -vf "scale=trunc(iw/2)*2:trunc(ih/2)*2" -vcodec libx264 -pix_fmt yuv420p dTest.mp4

# SIMULATION SECTOR
#sim_Steady(T)
#sim_Other_Boundary(T, d)
sim_dTest(T)

# Code to reset Colab database
!rm *.jpg
!rm *.mp4