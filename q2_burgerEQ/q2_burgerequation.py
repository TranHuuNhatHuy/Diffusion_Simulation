# -*- coding: utf-8 -*-
"""20B60130_TranHuuNhatHuy_Q2_BurgerEquation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1y595zQDycSnjQwV5mTKHRrqslOK04tM-
"""

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits import mplot3d

# Initial state properties
dx = dy = d = 1
dt = 0.1
v = 2
Lx = Ly = L = 100
x = np.arange(0, Lx + dx, dx)
y = np.arange(0, Ly + dy, dy)

# Simulation runtime properties
N_iter = 10000
N_reset = 100
X, Y = np.meshgrid(x, y)
U = np.zeros((len(x), len(y)))
U[20:80, 20:80] = 1.0
fig = plt.figure()

# Function to initiate plot with input U
def init_plt3D(U, zmin = 0, zmax = 1):
  plt.clf()
  ax = fig.add_subplot(projection = '3d')
  plot = ax.plot_surface(X, Y, U, cmap = 'nipy_spectral', vmin = zmin, vmax = zmax)
  ax.set_xlabel('X')
  ax.set_ylabel('Y')
  ax.set_zlabel('U')
  ax.set_zlim(zmin, zmax)
  plt.colorbar(plot)

# Function to obtain U[n+1] from previous U[n]
def get_U(U, a):
  U = U - a*dt/dx * (2*U - np.roll(U, 1, axis = 0) - np.roll(U, 1, axis = 1)) + v*dt/(dx**2) * (np.roll(U, 1, axis = 0) + np.roll(U, -1, axis = 0) + np.roll(U, 1, axis = 1) + np.roll(U, -1, axis = 1) - 4*U)
  return U

# Function to simulate linear case (when a is constant)
def sim_Linear(U):
  U_lin = U
  a = 0.55
  for i in range(N_iter):
    U_lin = get_U(U_lin, a)
    # Plot graphs every N_reset iterations
    if (i % N_reset == 0):
      icount = i // N_reset
      init_plt3D(U_lin, 0, 1)
      plt.savefig(f"L{icount:02d}.jpg")
  # Render animation
  !ffmpeg -r 6 -pattern_type glob -i 'L*.jpg' -vf "scale=trunc(iw/2)*2:trunc(ih/2)*2" -vcodec libx264 -pix_fmt yuv420p Linear.mp4

# Function to simulate non-linear case (when a is u itself)
def sim_NonLinear(U):
  U_non = U
  for i in range(N_iter):
    a = U_non                               # Update a every iteration
    U_non = get_U(U_non, a)
    # Plot graphs every N_reset iterations
    if (i % N_reset == 0):
      icount = i // N_reset
      init_plt3D(U_non, 0, 1)
      plt.savefig(f"N{icount:02d}.jpg")
  # Render animation
  !ffmpeg -r 6 -pattern_type glob -i 'N*.jpg' -vf "scale=trunc(iw/2)*2:trunc(ih/2)*2" -vcodec libx264 -pix_fmt yuv420p Nonlinear.mp4

# Function to obtain closed-wall condition
def get_U_closedWall(U, a):
  v_adv = a*dt/dx
  v_dif = v*dt/(dx**2)
  Uclone = U - v_adv * (2*U - np.roll(U, 1, axis = 0) - np.roll(U, 1, axis = 1)) + v_dif * (np.roll(U, 1, axis = 0) + np.roll(U, -1, axis = 0) + np.roll(U, 1, axis = 1) + np.roll(U, -1, axis = 1) - 4*U)
  # Recalculating 2 borders
  Uclone[0, :] = U[0, :] - v_adv * (U[0, :] - np.roll(U, 1, axis = 1))[0, :] + v_dif * (np.roll(U, -1, axis = 0)[0, :] + np.roll(U, 1, axis = 1)[0, :] + np.roll(U, -1, axis = 1)[0, :] - 3*U[0, :])
  Uclone[-1, :] = U[-1, :] - v_adv * (U[-1, :] - np.roll(U, 1, axis = 0)[-1, :] - np.roll(U, 1, axis = 1))[-1, :] + v_dif * ( np.roll(U, 1, axis = 0)[-1, :] + np.roll(U, 1, axis = 1)[-1, :] + np.roll(U, -1, axis = 1)[-1, :] - 3*U[-1, :])
  return Uclone

def sim_ClosedWall(U):
  U_cw = U
  a = 0.1         # Fixed for linear case 
  for i in range(N_iter):
    U_cw = get_U_closedWall(U_cw, a)
    # Plot graphs every N_reset iterations
    if (i % N_reset == 0):
      icount = i // N_reset
      init_plt3D(U_cw, 0, 1)
      plt.savefig(f"C{icount:02d}.jpg")
  # Render animation
  !ffmpeg -r 6 -pattern_type glob -i 'C*.jpg' -vf "scale=trunc(iw/2)*2:trunc(ih/2)*2" -vcodec libx264 -pix_fmt yuv420p ClosedWall.mp4

# SIMULATION SECTOR
#sim_Linear(U)
#sim_NonLinear(U)
sim_ClosedWall(U)

!rm *.jpg