# -*- coding: utf-8 -*-
"""20B60130_TranHuuNhatHuy_Q3_AdvectionEquation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WExUYK-EQwVp2ujpOZOOfKB6Q3nFI71M
"""

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits import mplot3d

# Initial state properties
dx = d = 1
Lx = L = 100
x = np.arange(0, Lx + dx, dx)
u = 1

# Simulation runtime properties
N_iter = 10000
N_reset = 100
F = np.zeros(len(x))
F[40:60] = 1
t_list = [10, 200, 400, 600]
c = 0.5
tMax = max(t_list)
fig = plt.figure()

# Function to initiate plot with input function F
def init_plt2D(F):
  plt.clf()
  ax = fig.add_subplot()
  ax.plot(x, F)
  ax.set_xlabel('X')
  ax.set_ylabel('F')

# Function to simulate up-wind scheme method
def sim_upwind(F, c):
  F = np.zeros(len(x))
  F[40:60] = 1
  pivotPos = 0
  for t in range(tMax + 1):
    # Approximating F through interpolation loop
    F = F - c * (F - np.roll(F, 1))
    # At each time pivot, plot to see how well F behaves
    if (t == t_list[pivotPos]):
      init_plt2D(F);                           # Plot
      plt.title(f"Upwind, c = {c}, t = {t}")
      plt.savefig(f"U-{c:1.1f}-{t:03d}.jpg")     # Get the graph shot
      pivotPos += 1

# Function to simulate Leith's method
def sim_Leith(F, c):
  F = np.zeros(len(x))
  F[40:60] = 1
  pivotPos = 0
  dt = c / u * dx
  for t in range(tMax + 1):
    # Obtain the next interpolation loop
    a = 1 / (2 * (dx**2)) * (np.roll(F, -1) - 2*F + np.roll(F, 1))
    b = 1 / (2 * dx) * (np.roll(F, -1) - np.roll(F, 1))
    F = F + (a * (u*dt)**2) - (b * u*dt)
    # At each time pivot, plot to see how well F behaves
    if (t == t_list[pivotPos]):
      init_plt2D(F);                           # Plot
      plt.title(f"Leith, c = {c}, t = {t}")
      plt.savefig(f"L-{c:1.1f}-{t:03d}.jpg")     # Get the graph shot
      pivotPos += 1

# Function to simulate CIP method
def sim_CIP(F, c):
  F = np.zeros(len(x))
  F[40:60] = 1
  pivotPos = 0
  dt = c / u * dx
  xi = -u * dt
  g = (np.roll(F, -1) - np.roll(F, 1)) / dx    # g is on tangent line, so g=dy/dx
  for t in range(tMax + 1):
    # At each time pivot, plot to see how well F behaves
    if (t == t_list[pivotPos]):
      init_plt2D(F);                           # Plot
      plt.title(f"CIP, c = {c}, t = {t}")
      plt.savefig(f"C-{c:1.1f}-{t:03d}.jpg")     # Get the graph shot
      pivotPos += 1
    # Obtain the next interpolation loop
    # We have u = 1 by default, so Xi = dx[i->iup] = x[i-1] - x[i] = -dx
    a = -2 * (np.roll(F, 1) - F) / ((-dx)**3) + (g + np.roll(g, 1)) / ((-dx)**2)
    b = -3 * (F - np.roll(F, 1)) / ((-dx)**2) - (2*g + np.roll(g, 1)) / (-dx)
    F = (a * xi**3) + (b * xi**2) + (g * xi) + F
    # Update new value of g for next loop
    g = (3 * a * xi**2) + (2 * b * xi) + g

def sim_anal(F, c):
  for t in t_list:
    C = abs(u * t / dx)                         # Courant number
    init_plt2D(np.roll(F, int(C)))              # Plot
    plt.title(f"Analytical, c = {c}, t = {t}")
    plt.savefig(f"A-{c:1.1f}-{t:03d}.jpg")      # Get the graph shot

# SIMULATION SECTOR
#sim_anal(F, c)     # Analytical solution
#sim_upwind(F, c)  
#sim_Leith(F, c)  
sim_CIP(F, c)

!rm *.jpg
!rm *.png